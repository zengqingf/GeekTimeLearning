using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OOP_Test_1
{
    /*
     设计原则：SOLID  KISS  YAGNI  DRY  LOD
     
        SOLID:
        SRP 单一职责原则 Single Responsibility Principle
            一个类或者模块只负责完成一个职责（或功能）    

            判断依据：
            类中的代码行数、函数或者属性过多；
            类依赖的其他类过多，或者依赖类的其他类过多；
            私有方法过多；
            比较难给类起一个合适的名字；
            类中大量的方法都是集中操作类中的某几个属性。

            类的职责不一定越单一越好:
            因为既需要低耦合，也需要高内聚；
            如果拆分的过细，影响内聚性，降低代码可维护性（比如改一处实现方法，其他各处都需要在不同类中去修改了）


        OCP 开闭原则  Open Closed Principle
            软件实体（模块、类、方法等）应该"对扩展开放，对修改关闭"
            
            实践中需要考虑到 
            开闭原则并不是完全杜绝修改 以最小的修改代码的代价完成新功能开发
            同样代码改动，在粗代码粒度下，可以认定为修改，在细代码粒度下，又可以认定为扩展
            不破坏原有代码的正常运行和原有的单元测试 
            尽量让修改操作更集中，更少，更上层；
            尽量让最核心、最复杂的那部分逻辑满足开闭原则

            常备意识：
            扩展、抽象、封装
           
            方法论：
            考虑未来的需求变更，事先留好扩展点
            识别出代码的可变和不可变部分，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用
            当具体的实现需要改变时，只需要基于相同接口，扩展一个新的实现，替换老的实现


            提高代码扩展性的方法：
            多态
            依赖注入
            基于接口而非实现编程
            （装饰、策略、模板、职责链、状态）
            

        LSP 里式替换原则  Liskov Substitution Principle
            子类对象(object of subtype/derived class)能够替换程序(program)中父类对象(object of base/parent class)出现的任何地方，
            并保证原来的程序逻辑不变和正确性 （也可以为 接口 和 实现类 之间的关系）

            目的 子类增强父类的同时， 保证父类接口一致性

            Design by contract 按照协议来设计
            在设计子类时，要遵守父类的行为约定（协议）父类定义了函数的行为约定，
            子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定
            （行为约定：函数声明要实现的功能；对输入、输出（返回值）、异常的约定；包括注释中所罗列的任何特殊说明）

            验证：
            用父类的单元测试去验证子类

            里式替换和多态的区别：
            两者关注角度不同，多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法 （一种代码实现思路）
            里式替换是一种设计原则，指导继承关系中子类如何设计

            
        ISP 接口隔离原则 Interface Segregation Principle
            客户端不应该被强迫依赖它不需要的接口（客户端：接口的调用者或者使用者）
            
            区分单一职责原则：
            接口隔离原则更注重接口的设计，某些情况下，需要通过调用者如何使用接口来间接地判定，可能调用者只需要使用部分接口或者接口的部分功能，这样接口设计职责不单一了

            接口：
            1.一组接口的集合
            2.单个API接口或者函数
            3.OOP中的接口

            
        DIP  依赖反转原则  Dependency Inversion Principle  (依赖倒置)

             1. 控制反转 IOC  (Inversion Of Control)
                框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。
                程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。

                这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。
                在使用框架之后，整个程序的执行流程可以通过框架来控制。
                流程的控制权从程序员“反转”到了框架

                模板模式

             2. 依赖注入 DI (Dependency Injection)
                不通过 new() 的方式在类内部创建依赖类对象，
                而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。
         
                同时需要注意 通过依赖注入方式 将外部类传入时 可以定义接口 这样基于接口而非具体实现（外部具体类） 更能提高代码扩展性

                
                依赖注入框架 （DI Framework）
                我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，
                就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

            3.  依赖反转原则 

                高层模块（high-level modules）不要依赖低层模块（low-level）  （高层为调用者，低层为被调用者）
                高层模块和低层模块应该通过抽象（abstractions）来互相依赖
                抽象（abstractions）不要依赖具体实现细节（details）
                具体实现细节（details）依赖抽象（abstractions）
         */


    class DesignPrinciples
    {

    }
}
