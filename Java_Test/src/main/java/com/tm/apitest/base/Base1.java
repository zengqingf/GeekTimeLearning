package com.tm.apitest.base;

public class Base1 {
    public static void baseData() {
        int bInt = 0b1111;
        int xInt = 0xf;
        int iInt = 15;
        int oInt = 0017;
        int ooInt = 017;
        System.out.println(bInt == xInt);   // true
        System.out.println(iInt == xInt);   // true
        System.out.println(iInt == oInt);   // true
        System.out.println(ooInt == oInt);  // true


        float fv = 3.14f;   //需要加f后缀

        char a = 'A';     //表示ASCII字符
        char zh = '中';   //可以表示 Unicode字符

        final double PI = 3.14;  //常量 通常大写

        /*数据溢出的原因：如加法运算时
         如十进制 2147483640 +  15 用二进制做运算时
            0111 1111 1111 1111 1111 1111 1111 1000
         +  0000 0000 0000 0000 0000 0000 0000 1111
         =  1000 0000 0000 0000 0000 0000 0000 0111

         最高位为 1 变为负数

         解决：使用long替换int（32）表示整型
        */

        //注意++写在前面和后面计算结果是不同的，
        // ++n表示先加1再引用n，n++表示先引用n再加1。
        // 不建议把++运算混入到常规运算中，容易自己把自己搞懵了。


        /***************************************  整型 ****************************************/


        /*
        * 位运算
        *
        * 1. 移位运算
        * 对byte和short类型进行移位时，会首先转换为int再进行位移。
          仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。
          *
          *
          2. 位运算
          *  &（与） |（或） ~（非） ^（异或，不同位1）
          *
          *
          3. 应用
          * a. 上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。
          *
          *
        * */

        //int类型 4字节二进制
        int n1 = 7;       // 00000000 00000000 00000000 00000111 = 7
        int a1 = n1 << 1;  // 00000000 00000000 00000000 00001110 = 14
        int b1 = n1 << 2;  // 00000000 00000000 00000000 00011100 = 28
        int c1 = n1 << 28; // 01110000 00000000 00000000 00000000 = 1879048192
        int d1 = n1 << 29; // 11100000 00000000 00000000 00000000 = -536870912

        int n2 = 7;       // 00000000 00000000 00000000 00000111 = 7
        int a2 = n2 >> 1;  // 00000000 00000000 00000000 00000011 = 3
        int b2 = n2 >> 2;  // 00000000 00000000 00000000 00000001 = 1
        int c2 = n2 >> 3;  // 00000000 00000000 00000000 00000000 = 0

        //对负数进行右移  最高位1不动  结果仍是一个负数
        int n3 = -536870912;
        int a3 = n3 >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
        int b3 = n3 >> 2;  // 11111000 00000000 00000000 00000000 = -134217728
        int c3 = n3 >> 28; // 11111111 11111111 11111111 11111110 = -2
        int d3 = n3 >> 29; // 11111111 11111111 11111111 11111111 = -1

        //无符号右移  不管符号位 高位补0
        int n4 = -536870912;
        int a4 = n4 >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
        int b4 = n4 >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
        int c4 = n4 >>> 29; // 00000000 00000000 00000000 00000111 = 7
        int d4 = n4 >>> 31; // 00000000 00000000 00000000 00000001 = 1


        /***************************************   浮点型  *************************************/
        /*
        * 浮点数不能做 位运算 和 移位运算
        *
        * 由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数
        *
        * Java 浮点数遵循 IEEE-754 标准
        *
        * 整型 + 浮点数 ： 整型自动提升到 浮点型
        * 两个整数的运算不会自动提升
         * */
        int ndf = 5;
        double df1 = 1.2 + 24.0 / ndf; // 6.0
        double df2 = 1.2 + 24 / 5; // 5.2       24/5 ~= 4
        /*
        * 溢出
        *
        * 整型除以0会报错，浮点数除以0会返回几个特殊值
        * NaN : Not a Number
        * Infinity 无穷大
        * -Infinity 负无穷大
        *
        * 可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值
        *
        *   int n1 = (int) 12.3; // 12
            int n2 = (int) 12.7; // 12
            int n2 = (int) -12.7; // -12
            int n3 = (int) (12.7 + 0.5); // 13
            int n4 = (int) 1.2e20; // 2147483647
         * */
        //四舍五入 方法：如可以对浮点数加上0.5再强制转型：
        double df = 2.6;
        int nf = (int) (df + 0.5);


        /*
        * boolean 运算
        * 一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。
        * 与运算和或运算是短路运算；
        * 三元运算b ? x : y后面的类型必须相同，三元运算也是“短路运算”，只计算x或y。
         * */


        /*
        * 字符 字符串
        * Java中 一个char保存一个 unicode 字符  占用2位
        * 因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个char类型表示，它们都占用两个字节。
        * 要显示一个字符的Unicode编码，只需将char类型直接赋值给int类型即可
        *
        * 还可以直接用转义字符\ + u编码来表示一个字符
        *
        *
        * Java13 可以用 ‘’‘。。。’‘’表示多行字符串
        *
        * Java中字符串不可变
        *
        * Java 空值   null != ""
         * */


        /*
        * 数组类型
        *
        * 数组创建后 大小不能改变  只能通过拷贝到新数组的方式扩展
        *
        * 数组的初始化方式
        *         int[] ns = new int[5];
        *         int[] ns = new int[] { 68, 79, 91, 85, 62 };
        *         int[] ns = { 68, 79, 91, 85, 62 };
        *
        * 数组本身是引用类型
         * */
    }
}
