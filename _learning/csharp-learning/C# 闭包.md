* 分析C#

  ![image-20220331225536892](C# 闭包.assets/image-20220331225536892.png)

  ![image-20220331225555126](C# 闭包.assets/image-20220331225555126.png)

  ![image-20220331225634910](C# 闭包.assets/image-20220331225634910.png)

  ``` tex
  实际上这个语法糖C#会生成内部静态类，然后在循环判断结束，会先去判断这个静态变量是否为空，为空则会用内部静态类的'<Main>b__0_0'生成一个action实例，将实例赋值给静态变量Action;
  ```

  ![image-20220331225915799](C# 闭包.assets/image-20220331225915799.png)

  ![image-20220331225929079](C# 闭包.assets/image-20220331225929079.png)

  ![image-20220331225940960](C# 闭包.assets/image-20220331225940960.png)

  ``` tex
  可以看到这个闭包类是在循环外部生成的，所以所有action指向同一个实例的同一个方法，故他们的输出是相同的
  ```

  ![image-20220331230108035](C# 闭包.assets/image-20220331230108035.png)

  ![image-20220331230126908](C# 闭包.assets/image-20220331230126908.png)

  ``` tex
  正常输出0,1,2,3,4,5,6,7,8,9
  可以看到只要生成10个实例，就能分别输出1-9了；
  ```

  ![image-20220331230230312](C# 闭包.assets/image-20220331230230312.png)

  ![image-20220331230245342](C# 闭包.assets/image-20220331230245342.png)

  ``` tex
  如果同时使用不同作用域变量的发现，会发现生成了两个闭包类；
  ```

  ![image-20220331230312474](C# 闭包.assets/image-20220331230312474.png)

  ![image-20220331230404034](C# 闭包.assets/image-20220331230404034.png)

  ![image-20220331230416069](C# 闭包.assets/image-20220331230416069.png)

  ![image-20220331230441130](C# 闭包.assets/image-20220331230441130.png)

  ``` tex
  3个不同生命周期的变量被闭包，生成了3个闭包类；
  ```

  ![image-20220331230517027](C# 闭包.assets/image-20220331230517027.png)

  ``` tex
  只会生成1个，虽然这两个闭包的内容完全一致，但是还是会生成两个Method
  ```

  ![image-20220331230610527](C# 闭包.assets/image-20220331230610527.png)

* 分析Unity

  ![image-20220331230631372](C# 闭包.assets/image-20220331230631372.png)

  ![image-20220331230648253](C# 闭包.assets/image-20220331230648253.png)

  ![image-20220331230659578](C# 闭包.assets/image-20220331230659578.png)

  ![image-20220331230720068](C# 闭包.assets/image-20220331230720068.png)

  ![image-20220331230731976](C# 闭包.assets/image-20220331230731976.png)

  ![image-20220331230820416](C# 闭包.assets/image-20220331230820416.png)

  ![image-20220331230910320](C# 闭包.assets/image-20220331230910320.png)

  ``` tex
  比较委托的实例是否相同&&比较委托方法是否相同,来判断是否移除事件；
  ```

  ``` tex
  如果是闭包的写法，实际上是表示两个闭包类的实例是否一致，以及是否是同一个闭包类的同一个函数；
  ```

  * 问题

    ``` tex
    这个闭包类是在for循环内部生成实例的
    ```

    ![image-20220331231035773](C# 闭包.assets/image-20220331231035773.png)

    ![image-20220331231102299](C# 闭包.assets/image-20220331231102299.png)

    ``` tex
    产生闭包类
    IL_042b对应 For循环2个判断条件，如果都成立则回到IL_0021，直接newobj一个闭包实例，也就是说每一次都生成一个新的实例；
    ```

    ![image-20220331231413995](C# 闭包.assets/image-20220331231413995.png)

    ![image-20220331231448827](C# 闭包.assets/image-20220331231448827.png)

    ![image-20220331231603556](C# 闭包.assets/image-20220331231603556.png)

    ``` tex
    再看移除监听事件的代码，为什么说地方移除事件移除不掉，回到之前的两个判断条件，1.是否是同一个闭包实例，2.是否是同一个方法。第一个条件满足不了，所以这个移除事件是移不掉的；
    ```

    ![image-20220331231715842](C# 闭包.assets/image-20220331231715842.png)

    ``` tex
    类似于下面这种错误方法
    可以看到RemoveListener对应'<>c'::'<OnEnable>b__4_0'()方法而AddListerner对应'<>c'::'<OnEnable>b__4_1'()方法。对应之前的条件2.是否是同一个方法，不是，所以也没办法移除事件。
    
    总结就是，移除事件的条件有2个，是否是同一个对象实例，以及是否是同一个方法；而产生问题的原因主要是，闭包时，对局部变量的引用，会导致多次生成闭包实例；
    ```

    ![image-20220331231741450](C# 闭包.assets/image-20220331231741450.png)

    ![image-20220331231758239](C# 闭包.assets/image-20220331231758239.png)