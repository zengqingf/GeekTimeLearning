# Unity API

 ### 项目结构

* 使用DLL

  ``` tex
  VS创建 xxx dll项目 --->  bin/Debug/XXX.dll
  
  Unity添加 Assets/Plugins/xxx.dll（可以考虑分平台 x64_86...）
  ```

  







---



### 内置API

* deviceUniqueIdentifier

  ``` c#
  iOS不支持，返回值不唯一！
  ```

  

* Awake vs. Start

  ``` tex
  ref: https://blog.csdn.net/haohan_meng/article/details/21857029
  Awake:
  	1.当脚本实例被加载时会调用Awake函数；Awake函数在所有的游戏对象被初始化完毕之后才会被调用；在脚本实例的整个生命周期中，Awake函数仅执行一次。
  	2.如果游戏对象（即gameObject）的初始状态为关闭状态，那么运行程序，Awake函数不会执行；反之，如果游戏对象的初始状态为开启状态，那么Awake函数会执行。并且，值得注意的一点是，Awake函数的执行与否与脚本实例的状态（启用或禁用）并没有关系，而是与脚本实例所绑定的游戏对象的状态有关。
  	3.在不切换场景的前提下，原本处于关闭状态的游戏对象，当它被首次开启时，Awake函数会执行，并且是只在首次开启时才会执行；而已经开启（激活）的游戏对象（Awake函数已经执行过一次），将它关闭后再次开启，Awake函数不会再次执行。看来这是对应了手册中说明的在脚本实例的整个生命周期中仅执行一次的情况。
  	4.如果重新加载场景，那么场景内Awake函数的执行情况重新遵循上述两点。
  	
  Start:
  	1.当Update函数第一次被调用前会调用Start函数；Start函数只在脚本实例被启用时才会执行；Start函数总是在Awake函数之后执行。
  	2.如果游戏对象被关闭，那么Start函数不会执行。
  	3.如果游戏对象开启了，对象上绑定的脚本实例被禁用了，那么Start函数不会执行。  即脚本被禁用
  	4.如果游戏对象开启了，对象上绑定的脚本实例也开启了，那么Start函数会执行。并且Start函数只会在脚本实例首次被开启时才会执行。如果是已经开启过的脚本实例被关闭后再次开启，那么Start函数不会再次执行。
  	5.如果重新加载场景，那么场景内Start函数的执行情况重新遵循上述三点。
  ```

  
