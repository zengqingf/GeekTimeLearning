# Unity游戏开发

* Assetbundle
* Editor
* Shader
* Unity Plugins
* 功能实现
* 玩法实现
* 优化



---



* behaviac   ref: https://www.behaviac.com/bd_vs_behaviac/
* graphic / texture compress 见wiz
* runtime permissions
* spine animation



---



### Unity性能优化

#### 界面优化

``` tex
特别是在界面打开的时候需要显示的元素上：
1.所有的显示和隐藏 不要用gameObject的set active, Image设置color的alpha, Text设置color的alpha, Button设置Image和Text的alpha.
如果是设置根节点 隐藏其下面所有子节点 在根节点上挂载CanvasGroup, 调用CanvasGroup的CustomActive.

2.在界面上有飞入动画，在飞入动画根节点有很多子节点的，例如背包的格子界面， 在所有子节点没有初始化好之前 最好是隐藏根节点，等所有子节点加载完成后 再显示，然后播放动画

3.在使用ScrollRect控件时 不要在Content里预先创建好需要用的预制体，要通过动态的创建。否则在ScrollRect初始化的时候会有很大的性能开销

4.UI控件的racastTarget没有需要响应事件的的不要勾上

5.对于大量重复的预制体 类似背包格子， 考虑使用对象池 和对象池的预加载

6.不要使用GetComponent和AddComponent, 用变量保存 通过unity的序列化赋值

7,Text的rich text能不用就不用，GC开销是2倍以上，时间开销是1.4倍以上(PC上测试)
```







---



### 游戏更新

* Unity il2cpp热更

  [Unity Android APP il2cpp热更新解决方案](https://www.gameres.com/830868.html)



* ILRuntime

  [github - ILRuntime](https://github.com/Ourpalm/ILRuntime)

  [ILRuntime入门笔记](https://www.cnblogs.com/zhaoqingqing/p/10274176.html)

  [对C#热更新方案ILRuntime的探究](https://www.cnblogs.com/zblade/p/9041400.html)

  ``` tex
  C#代码在编写后，是需要执行编译的，才能起效，这样如果在手机端，没有对应的编译环境，那么对应的c#代码就无法实现热更。ILRuntime实现的基础，也是基于AssetBundle的资源热更新方式，将需要热更新的c#代码打包成DLL，放在工程的StreamingAssets下，在每次完成资源打包后，对应的DLL会被作为资源热更新出去。这样就规避了编译相关的环节，实现了热更。
  ```

  



---



### 游戏案例

* 海战

  [从零开始用Unity做一个海战游戏](https://zhuanlan.zhihu.com/p/46569993)	[demo](https://github.com/tank1018702/unity-004)





---



### 读《Unity3D 高级编程 - 主程手记》

#### 一、架构

* 游戏架构

  * 前端渲染引擎
  * UI系统
  * AI行为算法，行为树？状态机？事件型决策树
  * 数据获取和存储
  * 场景拆分方式
  * 资源分离方式
  * 长连接or短连接
  * TCP or UDP
  * 服务端语言
  * 数据库，关系型？加入Cache机制？
  * 网络协议，ProtocolBuff? Json? XML? 自定义格式
  * ...

* 架构图

  * 在图上体现 抽象的系统、模块、组件

  * 体现子模块的细节

  * UML对象关系图、部署图、时序图等 从不同角度的架构图 整合为一个完整的项目架构图

  * 从宏观角度看，略去子系统的架构细节，可以直观展现整体的解决方案

    

* 架构好坏

  * 承载力

    能够承载多少个逻辑系统，代码行数限制，彼此工作的耦合度，人员共同开发数量和效率

    服务器承载量，日均访问量；客户端显示UI数量和渲染模型数量（同屏渲染和非同屏渲染）

  * 可扩展性

    能适应不同类型的需求，可添加不同类型的系统和不同功能的子系统

    关键在于添加新的子系统后不影响或者少影响其他子系统的运作

  * 易用性

    程序容易上手、子系统容易对接、各模块和部件只需要花费少量精力就能融合进架构，能集中在子系统的设计和编码上

  * 可伸缩性

    服务端可以根据用户数调整承载量、当人数减少时，缩减服务器数量，降低成本

    客户端能提供支持上百人开发的复杂系统，也适合小成本的快速迭代

  * 容错性和错误感知力

    服务器端包括数据库容错性、应用服务器容错性和缓存服务器容错型、以及中心服务器容错性

    当服务器出现故障、可以自动切换到备用服务器或者更换链路

    客户端指当程序发生错误时，保持运行而不奔溃；界面出错时，其他程序能正常运行

    奔溃或者错误日志能记录被发送云端，便于开发人员定期定位错误

  

* 思维方式

  抽象能力

  * 分层思维

    将复杂系统划分为若干层次，每一层专注解决一个领域的问题，并向上提供服务

    层次如果是纵向的，即会贯穿其他横向层，称之为共享层

    

  * 分治思维

    （主）code

    （附加）打包发布、资源部署到外网、检测、版本控制、设置项目管理平台

    先分解大问题成子问题，然后将子问题的解组合成原问题的解

  

  * 演化思维

    架构通过设计和演化形成

    应对持续变化的环境，调整架构以适应变化

  

* Unity3D项目

  * 前后端架构共性
    * 目标都是高性能、高可用、可扩展、安全、可容错
    * 前端还需要加入 用户体验、视觉效果、操作灵敏度和人性化等；需要考虑性能，加载流畅，特效，耗电量，快速响应用户操作等
    * 都是基于同一个系统层之上（Linux、Windows、Android、iOS等操作系统）
    * 前端基于渲染引擎建立游戏应用的业务架构（渲染引擎架构和游戏业务架构）
    * 后端基于操作系统构建了服务器框架

  * Unity3D架构

    ``` tex
    UI框架层
    核心逻辑框架层
    资源管理层
    数据管理层
    网络层
    ```

    ``` tex
    UI框架层
    
    核心逻辑框架层：工具编辑器、角色行为框架、AI框架、地图场景与寻路框架、着色器和特效、设备平台
    
    资源管理层：AssetBundle资源管理、Prefab资源管理
    
    数据管理层：内存数据管理、外部数据管理
    
    网络层
    ```

    ``` tex
    网络：
    	TCP	
    		HTTP
    		Socket
    	UDP
    	
    	接口拆分：
    		连接、断开连接、发送数据、接收数据
    		断开、连接、终止等网络事件
    	
    
    数据表：
    	Excel导出为二进制、Json或其他，读取和解析接口的定义
    	
    UI层：
    	确定UI框架，UGUI或其他
    	界面基类、界面打开关闭管理、界面层级管理、输入（监听）事件封装、自定义通用组件基类和各类功能性通用组件
    	
    外部资源管理：
    	确定使用AssetBundle，对其进行资源分类、资源间的依赖关系，加载和释放资源，加密资源
    	
    AI层：
    	使用状态机还是行为树、或决策树等
    	状态机、行为树接口实现、AI可视化工具、AI接口扩展
    	
    地形地图：
    	2D和3D确定
    	场景编辑器结构、是否需要网格合并，场景物件区分，大地形如何显示，分区块
    	
    寻路与网格：
    	确定寻路算法：A*算法、跳点算法或其他
    	使用网格栅格还是三角网格
    	长距离寻路还是地图数据管理
    	
    常用库：
    	时间函数、数学函数、数字变量加密封装、坐标转换函数、Debug调试工具、各大逻辑系统通用工具等
    	
    角色行为控制：
    	人物移动处理、摄像机碰撞检测、动画特效编辑器、技能编辑器、行为流的建立
    	
    2D动画控制：
    	包括动画组件封装、2D动画制作、2D图合并为图集
    ```

    

  

#### 二、C#



