### 基于权重的随机选择算法

* ref

  [基于权重 的随机选择算法 - 随机出一个值](https://zhuanlan.zhihu.com/p/146216606)

  [A Faster Weighted Random Choice](https://blog.bruce-hill.com/a-faster-weighted-random-choice)

  [Darts, Dice, and Coins: Sampling from a Discrete Distribution](https://www.keithschwarz.com/darts-dice-coins/)

  ``` tex
  从一系列道具中随机抽出一个发给玩家，由于道具的价值不一样，所以抽取的概率并不是平均的。后台会处理成高价值的东西很难得到，要实现这种效果，需要给每个道具指定一个权重。比如道具A的权重是99，道具B的权重是1，那么99%的概率会抽到道具A，这就是基于权重的随机算法。
  ```

  * 线性扫描

    ``` tex
    实现按权重随机的最简单方法是线性扫描，大概过程是先计算出所有道具的权重总和S，然后调用随机函数得到一个区间在[0, S)的随机值，接着从头向后扫描道具列表，并不断从S减掉每个道具的权重值，当S小于某个道具的权重值时，这个道具就是抽中的那一个。
    
    不适用于大量的道具
    
    优化方法一：先对weights进行排序，将权重大的放在前面，可能减少遍历次数
    但是由于是线性的，时间复杂度还是O(n)，同时当权重值相差小的情况下，优化效果不明显
    ```

    ``` lua
    -- 线性扫描
    local function prepare_weighted_random1(values, weights)
        assert(#values == #weights)
        local sum = 0       -- 计算总权重
        for _, wt in ipairs(weights) do
            sum = sum + wt
        end
        return function()
            local n = math.random(1, sum)       -- 线性扫描
            for idx, wt in ipairs(weights) do
                if n <= wt then
                    return values[idx], weights[idx]
                end
                n = n - wt
            end
        end
    end
    ```

  * 二叉查找

    ``` tex
    先计算出总和列表，列表中每个值是前面N个权重值的总和，这样这个列表就是有序的，再对这个列表使用二叉查找得到权重索引
    
    时间复杂度 O(log(n))
    ```

    ``` lua
    -- 二叉查找
    local function prepare_weighted_random2(values, weights)
        local totals = {}       -- 总和列表
        local sum = 0
        for i, w in ipairs(weights) do
            sum = sum + w
            totals[i] = sum
        end
    
        -- 返回选择器函数
        return function()
            local n = math.random() * sum
            local mid, distance
            local low, high = 0, #weights
            while low < high do
                mid = (low + high) // 2
                distance = totals[mid+1]
                if distance < n then
                    low = mid + 1
                elseif distance > n then
                    high = mid
                else
                    low = mid
                    break
                end
            end
            return values[low+1], weights[low+1]
        end
    end
    ```

  * 跳选索引

    ``` tex
    先对权重列表进行排序，使大的权重在前面，然后从第1个索引开始，快速跳过一些索引并到达目标；之所以能快速到达目标是基于一个前提：当前索引的权重必然比后面索引的权重大(或等于)，因此用随机值减掉当前索引的权重总和，再去除当前权重，就能快速逼近目标索引：
    
    有两种极端情况，一种是权重值全部相等时，只需要2次就能找到目标索引；另一种是2的幂逐级减少，比如[32,16,8,4,2,1]，这样就退化成遍历N次才能找到，因为第N个权重总是比后面所有权重加起来都大，随机值再大除下来都是1。除了这两种极端情况，其他时候都表现得很好。
    ```

    ``` lua
    -- 跳房子
    local function prepare_weighted_random3(values, weights)
        assert(#values == #weights)
        local tinsert = table.insert
        local ipairs = ipairs
    
        local sorted_indices  = {}      -- 排序的权重索引
        for i, _ in ipairs(weights) do
            tinsert(sorted_indices, i)
        end
        table.sort(sorted_indices, function(a, b)
            return weights[a] > weights[b]
        end)
    
        local sorted_weights = {}   -- 排序的权重列表
        for _, i in ipairs(sorted_indices) do
            tinsert(sorted_weights, weights[i])
        end
    
        local totals = {}       -- 总和列表
        local sum = 0
        for i, w in ipairs(sorted_weights) do
            sum = sum + w
            totals[i] = sum
        end
    
        -- 返回选择器函数
        return function()
            local n = math.random() * sum
            local idx = 1
            local distance, weight, sidx
            while true do
                if totals[idx] > n then     -- 找到
                    sidx = sorted_indices[idx]
                    return values[sidx], weights[sidx]
                end
                weight = sorted_weights[idx]
                distance = n - totals[idx]
                idx = idx + (1 + distance // weight)
            end
        end
    end
    ```

  * 别名方法

    ``` tex
    算法思路：
    将权重总和切成N个桶，N就是weights的数量，桶的大小就是平均权重。
    从weights中得到一个小于平均权重的列表，和一个大于等于平均权重的列表。
    取出一个小权重放入桶中，桶还有一点空间用来放一个大权重的一部分。
    一直重复这个过程，直到桶都填完，最终得到aliases这个数据结构。
    aliases的索引是小权重的索引，aliases的每个元素由两个值组成：第一个是小权重占的比例，第二个是大权重的索引。
    
    
    ```

    ``` lua
    -- 别名方法
    local function prepare_weighted_random4(values, weights)
        assert(#values == #weights)
        local tinsert = table.insert
        local ipairs = ipairs
    
        local count = #weights
        local sum = 0       -- 计算总和
        for _, w in ipairs(weights) do
            sum = sum + w
        end
        local avg = sum / count     -- 平均权重
    
        local aliases = {}      -- 别名表
        for _, _ in ipairs(weights) do
            tinsert(aliases, {1, false})
        end
    
        local sidx = 1  -- 找到第1个小于平均值的索引
        while sidx <= count and weights[sidx] >= avg do
            sidx = sidx + 1
        end
        if sidx <= count then   -- 如果 small_i > count 表示所有权重值相等，什么也不用处理
            local small = {sidx, weights[sidx] / avg}
            local bidx = 1      -- 找到第1个大于等于平均值的索引
            while bidx <= count and weights[bidx] < avg do
                bidx = bidx + 1
            end
            local big = {bidx, weights[bidx] / avg}
    
            while true do
                aliases[small[1]] = {small[2], big[1]}  -- 桶的索引即是小权重的索引，从中去掉小权重的比例，剩余的放大权重
                big = {big[1], big[2] - (1-small[2])}   -- 大权重去掉已放入的比例
                if big[2] < 1 then  -- 如果大权重剩余的比例已小于1，表示小于平均权重
                    small = big     -- 大权重变成小权重
                    bidx = bidx + 1 -- 找下一个大权重的索引
                    while bidx <= count and weights[bidx] < avg do
                        bidx = bidx + 1
                    end
                    if bidx > count then
                        break
                    end
                    big = {bidx, weights[bidx] / avg} -- 得到下一个大权重
                else    -- 大权重的比例大于等于1，表示不比平均权重小，继续找小权重
                    sidx = sidx + 1     -- 找下一个小权重索引
                    while sidx <= count and weights[sidx] >= avg do
                        sidx = sidx + 1
                    end
                    if sidx > count then
                        break
                    end
                    small = {sidx, weights[sidx] / avg}
                end
            end
        end
    
        return function()
            local n = math.random() * count
            local i = math.floor(n)
            local odds, alias = aliases[i+1][1], aliases[i+1][2]    -- 小权重比例，大权重索引
            local idx
            if n - i > odds then
                idx =  alias
            else
                idx = i + 1
            end
            return values[idx], weights[idx]
        end
    end
    ```

  * 测试

    ``` lua
    local function benchmarks()
        local values = {}
        local weights = {}
        for i = 1, 10000 do
            values[i] = i
            weights[i] = math.random(1, 1000)
        end
    
        local randomizers = {
            {"Linear Scan", prepare_weighted_random1(values, weights)},
            {"Binary Search", prepare_weighted_random2(values, weights)},
            {"Hopscotch Selection", prepare_weighted_random3(values, weights)},
            {"Alias Method ", prepare_weighted_random4(values, weights)},
        }
    
        for _, randomizer in ipairs(randomizers) do
            local tm = os.clock()
            for i = 0, 10000 do
                randomizer[2]()
            end
            print(string.format("%s time = %s", randomizer[1], os.clock() - tm))
        end
    end
    benchmarks()
    ```

    