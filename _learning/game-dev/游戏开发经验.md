### 经验

* 编码

  1. 不能按照服务器协议做逻辑，协议先后顺序没有保证的
  1. 代码里尽量不要使用写死的string，需要放到通用文件里，运行时加载到内存，同时涉及到多语言发布时，还方便统一替换文本

  

* lua语言

  1. lua的智能提示很重要 容易造成逻辑出错

     例如：函数少传参数导致函数执行逻辑不对，需要多次测试才能发现
  
  2. lua进行业务逻辑开发时，多考虑用表去代替多个if else
  
  3. lua代码中写字符串或者需要拼接字符串时，需要考虑使用 不带引号的 [[XXX]]，XXX中可以包含\n，并且\n不为转义符，仅表示\n这两个字符
  
  4. lua初始化变量或者方法调用设置变量时  使用  变量 or + 默认值
  
     ``` lua
     function ItemData:SetCount(count)
         self.mItemCount = count or 1
     end
     ```
  
  5. lua和c++ 或者 lua和c# 之间相互调用，需要分清楚lua是辅助层，装饰层，是基于c++或者c#的，所以尽量不要发生从c++调用lua函数，这个lua函数又是c++实现的，增加性能消耗
  
  6. **lua回调需要注意传回调实现所在的对象**
  
     ``` lua
     -- ItemBatchUseFrameView_C
     	function ItemBatchUseFrameView_C:Init()
         	ItemNumInputField_C:Init(self, self.OnSmallKeyboardViewReturn)
         end
         function ItemBatchUseFrameView_C:OnSmallKeyboardViewReturn(value)
             batchUseNum = value
         end
     
     -- ItemNumInputField_C
     	function ItemNumInputField_C:Init(target, callback)
         	self.mTarget = target
         	self.mSmallKeyboardEnterCallback = callback
         end
     	function ItemNumInputField_C:OnSmallKeyboardEnterCallback(value)
             if self.mSmallKeyboardEnterCallback ~= nil then
                 self.mSmallKeyboardEnterCallback(self.mTarget, self.mUseNum)
             end
         end
     ```
  
     * lua中含有回调的接口定义，**需要考虑到传入的回调函数是定义在哪个table中的，时刻注意！！！**
  
       ``` lua
       --定义：创建任务追踪Item
       --注意：传入创建依赖的frame
       --注意：回调函数第一参数，传回指定的frame
       function TaskDataManager:CreateTaskTraceItem(frame, taskId, createSuccCallback, createFailCallback)
           if nil == frame then
               return
           end
           local taskData = self:GetAvaiableTaskData(taskId)
           if nil == taskData then
               if createFailCallback ~= nil then
                   createFailCallback(frame)
               end
               return
           end
           local fakeTaskWidgetItemData = self:NewCopyTaskWidgetItemData(taskData)
           if nil == fakeTaskWidgetItemData then
               if createFailCallback ~= nil then
                   createFailCallback(frame)
               end
               return
           end
           UIManager.LoadWidget(frame, TASK_WIDGET_ITEM_PATH, 
           function(self, widget, path, userData)
               ---@class MainTownTaskItem_C
               if widget ~= nil then
                   widget:Init(userData)
               end
               if createSuccCallback ~= nil then
                   createSuccCallback(frame, widget, userData)
               end
           end,
           function(self, path, userData)
               if createFailCallback ~= nil then
                   createFailCallback(frame)
               end
           end,
           fakeTaskWidgetItemData)
       end
       
       
       --使用时，可以使用MainTownTaskWidget_C._TestCreateTaskTraceItemSucc 或者 self._TestCreateTaskTraceItemSucc
       --定义_TestCreateTaskTraceItemSucc时，使用:或者.加self
       function MainTownTaskWidget_C:Init()
           CommonUtility.UpdateHitTestInvisible(self.NoMainTaskRoot, true)
           TaskDataMgr:CreateTaskTraceItem(self, taskIdList[1]:TaskId(), 
               							self._TestCreateTaskTraceItemSucc, self._TestCreateTaskTraceItemFail)
       end
       function MainTownTaskWidget_C:_TestCreateTaskTraceItemSucc(widget, userData)
           if widget ~= nil then
               self.NoMainTaskRoot:AddChildToOverlay(widget)
           end
       end
       function MainTownTaskWidget_C:_TestCreateTaskTraceItemFail()
       end
       ```
  
       
  
  7. lua  local param vs. self param
  
     ``` lua
     local PackageBagView_C = {}
     
     -- 每次创建当前PackageBagView_C 对象（表）时，如果不重置下表，则会缓存之前的数据
     local updateSortFirstFlags = {
             [PackageType.eEquip] = true,
             [PackageType.eConsumable] = false,
             [PackageType.eMaterial] = false,
             [PackageType.eFashion] = false,
     }
     
     -- 每次创建当前PackageBagView_C 对象（表）时，都会创建一份新的数据，但是在对象销毁时，还是需要重置一下表中的变量，以免变量引用了外部对象
     self.mUpdateSortFirstFlags = {
             [PackageType.eEquip] = true,
             [PackageType.eConsumable] = false,
             [PackageType.eMaterial] = false,
             [PackageType.eFashion] = false,
     }
     
     return PackageBagView_C
     ```
  
  8. lua引用另一个文件里定义的枚举时，需要require这个文件，即使引入的对象在IDE上显示没用到
  
  9. lua 写接口时 需要在备注里 注明 返回值 以及 返回值是否为空
  
  10. **考虑到一个table所承载的class对象，可能会多次刷新，而非重建，所以内部变量尽量不要使用静态变量（即local，所用self）**
  
  11. lua赋值需要先判空
  
      ```  lua
      ...
      --随机属性
      	--如果不加这一行，但是变量是nil，lua会直接中断这个方法
          if item.randomAttrs ~= nil and item.randomAttrs.randomAttrVec ~= nil then  
              itemData.mRandomAttrs = item.randomAttrs.randomAttrVec
          end
      ...
      ```
  
  12. 显示相关，关于0
  
      ``` lua
      local remainTime = totalTimes - currTime
      if remainTime < 0 then			--凡是取值会靠近0，需要判断展示时是否需要展示小于0的情况，否则都要做保护
         remainTime = 0
      end
      ```
  
  13. lua在方法中报错，会中断，跳出当前方法
  
      ![image-20220328082806389](游戏开发经验.assets/image-20220328082806389-16484272887861.png)
  
  14. lua定义函数的入参
  
      ``` lua
      function CommonUtility.GetNumByKeepDecimalFloor(num, n)
          if type(num) ~= "number" then							--入参进行类型判断
              return num
          end
      end
      ```
  
  15. lua变量传值和传引用
  
      ``` lua
      lua中table是通过引用传递
      
      实践时如果发现table构建的对象不是按照引用传递，需要检查table构建对象的数据是否有被更新
      ```
  
      ``` tex
      Lua数据的拷贝和引用问题
      
      举例：发现缓存的Current Skill Data 存的等级没更新
      	只有这种情况才会更新等级，导致其他更新操作时，数据没有更新
      
      解决：重新从整个数据结构中获取最新的数据 赋予缓存的data
      ```
  
      ![img](游戏开发经验.assets/企业微信截图_16566686692729.png)
  
      ![image-20220701180631087](游戏开发经验.assets/image-20220701180631087-16566699929411.png)
  
      
  
  16. Lua表长度;
  
      ``` lua
      local roleInfo = {
          [0] = { name = "", age = 18 },
          [1] = { name = "", age = 18 }
      }
      
      print(#roleInfo) --output: 1
      ```
  
  17. Lua type of custom table class 输出结果为table
  
      ``` lua
      print('### type of taskdata', type(taskData))  --output: table
      
      if type(taskData) == 'TaskDetailData' then
           taskId = taskList[i] ~= nil and taskList[i]:TaskId() or 0
      elseif type(taskData) == 'TaskSimpleData' then
           taskId = taskList[i] ~= nil and taskList[i]:GetTaskId() or 0
      end
      ```
  
      ``` lua
      ---@class TaskDetailData : LuaClass
      local TaskDetailData = class("TaskDetailData")
      return TaskDetailData
      ```
  
      ``` lua
      ---迭代浅拷贝
      ---@param object any
      ---@return any
      function Clone(object)
          local lookup_table = {}
          local function _copy(object)
              if type(object) ~= "table" then
                  return object
              elseif lookup_table[object] then
                  return lookup_table[object]
              end
              local new_table = {}
              lookup_table[object] = new_table
              for key, value in pairs(object) do
                  new_table[_copy(key)] = _copy(value)
              end
              return setmetatable(new_table, getmetatable(object))
          end
          return _copy(object)
      end
      
      local function Index(t, k)
          local mt = getmetatable(t)
          local Super = mt
          while Super do
              local v = rawget(Super, k)
              if v~= nil then
                  if rawequal(v, NotExist) then
                      return nil
                  end
                  rawset(t, k, v)
                  return v
              end
              Super = rawget(Super, "Super")
          end
          local p = mt[k]
      
          if p ~= nil then
              if type(p) == "userdata" then
                  return GetUProperty(t, p)
              elseif type(p) == "function" then
                  rawset(t, k, p)
              elseif rawequal(p, NotExist) then
                  return nil
              end
          else
              rawset(mt, k, NotExist)
          end
          return p
      end
      
      local function NewIndex(t, k, v)
          local mt = getmetatable(t)
          local p = mt[k]
          if type(p) == "userdata" then
              return SetUProperty(t, p, v)
          end
          rawset(t, k, v)
      end
      
      ---Create an class. 对应智能提示LuaClass
      ---@diagnostic disable-next-line:lowercase-global
      function class(classname, Super)
          local superType = type(Super)
          local cls
          
          if superType ~= "function" and superType ~= "table" then
              superType = nil
              Super = nil
          end
      
          if superType == "function" or (Super and Super.__ctype == 1) then
              -- inherited from native C++ Object
              cls = {}
      
              if superType == "table" then
                  -- copy fields from Super
                  for k,v in pairs(Super) do cls[k] = v end
                  cls.__create = Super.__create
                  cls.Super    = Super
              else
                  cls.__create = Super
              end
      
              cls.ctor    = function() end
              cls.cname = classname
              cls.__ctype = 1
      
              function cls.New(...)
                  local instance = cls.__create(...)
                  -- copy fields from class to native object
                  for k,v in pairs(cls) do instance[k] = v end
                  instance.class = cls
                  instance:Ctor(...)
                  return instance
              end
      
          else
              -- inherited from Lua Object
              if Super then
                  cls = Clone(Super)
                  cls.Super = Super
              else
                  cls = {ctor = function() end}
              end
      
              cls.cname = classname
              cls.__ctype = 2 -- lua
              cls.__index = Index
              cls.__newindex = NewIndex
      
              function cls.New(...)
                  local instance = setmetatable({}, cls)
                  instance.class = cls
                  instance:Ctor(...)
                  return instance
              end
          end
      
          return cls
      end
      ```
  
      





---



### 客户端系统开发

* 尽量不要使用sprite加载的方式动态设置ui，除非是图片大小一样的情况并且需要动态切换

* 城镇数据和战斗数据 尽量分开 ，如果使用通用数据管理器，尽量加一份工具函数（不包含城镇数据或者战斗数据），避免因为误带入对方数据导致异常

* 客户端和服务器联调协议时，设计枚举值的定义，客户端可以根据现有映射一份少量枚举值，这样当服务器需要改动枚举时，可以单独和其开发服务器联调

* Frame（指定界面管理层）需要尽量全部承担业务逻辑，View只是接收数据，改变UI，或者UI交互，发送UI事件；需要将View里的业务逻辑功能抽出来放到Frame里，因为View经常会变动，界面调整，按钮调整，显示调整，但是基本功能点不变

* 客户端数据管理需要考虑 进入游戏和退出到登录 两种情况下 数据的创建、声明和事件绑定，以及相应的清理或者重置（e.g. DataMgr InitData() UninitData() ResetData() ）

* 道具模块

  ``` tex
  对于Comitem和ItemTip，除非策划需求真假道具在tips上的显示有区别；或者在道具icon上，真假道具的显示有区别，才需要手动做区分
  
  否则，真道具有的数据和流程，假道具创建时也需要有，保证构造数据的一致性，区别只是数据来源不同
  ```

* 系统配表

  ``` tex
  能拆分表格就拆分 保证字段在每个表格功能一致且相关，虽然对于策划配表需要多张表一起修改，但是功能含义上会比较明确
  如道具表和道具用途表，道具表中包含用途表ID，道具使用条件在道具表中，道具用途和道具使用并不相关
  ```

* 代码开发规范

  * if...else... 需要配套

    ![image-20220402142122750](游戏开发经验.assets/image-20220402142122750-16488804840631-16488805105892.png)
  
* 业务代码性能优化

  * 数据类中使用外部接口获取同一份数据，多次在数据类的几个地方调用，上层使用数据类时，产生这几个地方的多次调用，会导致计算量很大

    ![image-20220809150926560](游戏开发经验.assets/image-20220809150926560.png)

