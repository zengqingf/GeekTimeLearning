# 编译原理

## 编译器

* 简介
  
  ```tex
  编译器是将用某种程式语言写成的源代码（源语言），转换成另一种程式语言（目标语言）等价形式的程序。通常我们是将某种高级语言（如C、C++、C# 、Java）转换成低级语言（汇编语言、机器语言）
  ```

* 工作形式
  
  ```tex
  编译器以流水线的形式进行工作，分为几个阶段：源代码 → 词法分析 → 语法分析 → 语义分析 → 目标代码 → 链接 → 可执行文件。现代编译器还会更复杂，中间会增加更多的处理过程，比如预处理器，中间代码生成，代码优化等
  ```
  
  ![](https://raw.githubusercontent.com/MJX1010/PicGoRepo/main/img/20210717104741.jpg)

---

## 虚拟机

* 简介
  
  ```tex
  可以执行特定指令的一种程序
  为了执行指令，还需要一些配套的设施，如寄存器、栈等
  
  虚拟机本身并不跨平台，而是语言是跨平台的
  
  例如：
  在编译器领域，虚拟机通常执行一种叫中间代码的语言，中间代码由高级语言转换而成，以 Java 为例，Java 编译后产生的并不是一个可执行的文件，而是一个 ByteCode （字节码）文件，里面包含了从 Java 源代码转换成等价的字节码形式的代码。Java 虚拟机（JVM）负责执行这个文件。
  ```

* 工作形式
  
  ```tex
  虚拟机执行中间代码的方式分为 2 种：解释执行和 JIT（即时编译）。
  解释执行即逐条执行每条指令，JIT 则是先将中间代码在开始运行的时候编译成机器码，然后执行机器码。由于执行的是中间代码，所以，在不同的平台实现不同的虚拟机，都可以执行同样的中间代码，也就实现了跨平台。
  ```

---

## 编译阶段

* 编译的各个阶段
  
  编译工作可以分成若干阶段，每个阶段把源程序从一种表示转换到另一种表示
  
  * 词法分析
    
    ```tex
    阅读构成源程序的字符流，按编程语言的词法规则把它们组成词法记号(token)流
    ```

* 语法分析 (syntax analysis)
  
  ```tex
  简称分析(parsing)
  检查词法分析输出的记号流是否符合编程语言的语法规则，并依据这些规则所体验出的语言构造（construct，如函数、语句、表达式等）的层次性，用各记号的第一元建成一种树形的中间表示，这个中间表示用抽象语法的方式描绘了该记号流的语法情况
  一种典型的中间表示是语法树，其中内部结点表示运算，它们的子结点代表该运算的运算对象
  ```

* 语义分析
  
  ```tex
  使用语法树和符号表中的信息，依据语言定义来检查源程序各部分之间的语义一致性，以保证程序各部分能有意义的结合在一起
  还会收集类型信息，将收集的类型信息保存到符号表或语法树
  
  类型检查是重要的一部分，编译器会检查每个算符的运算对象，看它们的类型是否适当，例如，当实数作为数组的下标时，许多语言的定义都要求编译器报告错误
  语言定义也可能允许运算对象的类型做隐式转换，例如当二元算术符作用于一个整数和一个实数时，编译器会把其中的整数转换为实数
  ```

* 中间代码生成
  
  ```tex
  经过语法分析和语义分析后，许多编译器为源程序产生更低级的显式中间表示，可以把这种中间表示想象成一种抽象机的程序
  这种中间表示必须具有两个性质，易于产生并且易于翻译成目标程序
  ```

* 代码优化
  
  ```tex
  独立于机器的代码优化阶段试图改进中间代码，以便产生较好的目标代码，通常，“较好”是指执行较快，但也可能期望其他目标，如目标代码较短或目标代码执行时能耗较低
  ```

* 代码生成
  
  ```tex
  取源程序的一种中间表示作为输入并把它映射到一种目标语言，如果目标是机器代码，则需要为源程序所用的变量选择寄存器或内存单元，然后把中间指令序列翻译为完成同样任务的机器指令序列
  ```

---





### 汇编

* 语法1

  ``` tex
  dword   双字 就是四个字节
  ptr     pointer缩写 即指针
  []里的数据是一个地址值，这个地址指向一个双字型数据
  比如mov eax, dword ptr [12345678]  把内存地址12345678中的双字型（32位）数据赋给eax 
  ```

  
