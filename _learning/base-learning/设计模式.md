# 设计模式



### UML

![](_pic/uml_1.png)





---

### 术语

* google ngram viewer   关键词使用规模比较

  https://books.google.com/ngrams/graph?content=indexes%2Cindices&year_start=1800&year_end=2000&corpus=15&smoothing=3&direct_url=t1%3B%2Cindexes%3B%2Cc0%3B.t1%3B%2Cindices%3B%2Cc0

* handle vs. handler

  [闲话handle和handler](https://www.cnblogs.com/idorax/p/6414007.html)

  ``` text
  handle: 句柄(勾柄)
  a handle is an abstract reference to a resource
  是对某个资源的抽象引用
  
  unix / linux中
  进程号pid就是一个handle
  文件描述符(fd)也是一个handle
  系统调用号(syscall num)仍然是一个handle
  
  在操作系统中，一切对用户来说是透明(注：这里的"透明"指的是"看不见摸不着就如空气一样"而不是"一览无余毫无秘密可言")的但是操作系统内核看得懂的无符号整数(unsigned int)都可以被看作是handle
  
  在操作系统设计与实现中，联系内核态和用户态，靠的就是一个个无符号整数
  一个unsigned int占4个字节，可以表征的通信密码总数为2^32(=4G, 约40亿)
  
  对于持有handle的用户，不需要关心内部（内核）资源的具体实现，不能直接访问内核资源，而一个被内核映射成指向内核资源的首地址pointer才能访问真正的内核资源
  
  
  handler: 回调函数（callback）, 或者用delegate / del 等表示
  当某个事件到达时，事先注册的handler会被接收到事件的主体所调用
  is an asynchronous callback subroutine
  是一个异步的回调函数（子程序）
  
  ```

  

* data vs. info

  ``` tex
  data 未经过整理的
  infomation/info  经过组织分析后的数据
  ```

  ``` tex
  data  （datum的复数形式）
  Data is raw, unorganized facts that need to be processed. Data can be something simple and seemingly random and useless until it is organized.
  
  e.g 每个学生成绩
  
  
  infomation/info
  When data is processed, organized, structured or presented in a given context so as to make it useful, it is called information.
  
  "the act of informing"（告知行为） usually in regard to education, instruction, or other knowledge communication.
  
  e.g 平均成绩（从给定data中得到的信息）
  ```



* OnXXXClick / OnXXXSelected / OnXXXUpdate...   vs.   SelectedXXXCallback / UpdateXXXCallback

  ``` tex
  OnXXXUpdate 是指代 XXX内部发生改变（Update）时, 通知外部对象
  UpdateXXXCallback 是指代 外部对象改变XXX，XXX内部作出响应的变化
  
  都是为了降低耦合，使用一个委托（事件）进行拆分两种对象
  ```

  

* Update vs. Upgrade vs. Refresh

  ``` tex
  Update: 获得某物的最新版本	"I need to update this app on my phone"
  						将内存中的对象写入数据库（View Update Model）   						 更新数据
  Upgrade: 得到比现在拥有的更好的东西	"I need to upgrade to a new phone."  （升级手机或换手机）
  Refresh: 查看最近的东西	"I need to refresh the page to see if there is anything new."
  						用数据库更新内存中的对象（内存对象可以看作View, Model Refresh View）		刷新界面
  ```



* Task vs. Mission

  ``` tex
  task 主要表达“工作”、“差事”之意，表示雇主、父母或者老师所摊派、分配、布置或者强加给的工作。比如，XX派某人去执行某个差事。再比如，XX能胜任这样一项工作。（He is equal to such a task.）
  mission 主要表达“使命”、“天职”之意。比如，XX大使带着外交使命出访某国。
  
  As nouns the difference between mission and task is that mission is (countable) a set of tasks that fulfills a purpose or duty; an assignment set by an employer while task is a piece of work done as part of one’s duties.
  As verbs the difference between mission and task is that mission is to send to a mission while task is to assign a task to, or impose a task on.
  作为名词，mission和task的区别在于，mission是(可数的)一组完成目的或职责的任务;由雇主安排的任务，而task是作为一个人的职责的一部分完成的工作。
  作为动词，mission和task的区别在于mission是发送任务，而task是分配任务或强加任务。
  
  Task most likely means something small and simple, like a chore
  Mission can mean like an errand or striving for a goal that requires much effort (like spy movies)
  Assignment: a job/task that is assigned to you. Like a homework assignment.
  任务,很可能是指一些小事和简单的事情，比如家务
  使命,可以是一项使命，或者是为一个需要付出很大努力的目标而奋斗(就像间谍电影)
  分配,分配给你的工作/任务。就像家庭作业一样。
  ```

  



* bind event(handlers) vs. register handler

  ``` tex
  现在就认为
  
  持久存在的对象，如DataManager，使用	Bind Events，如BindUIEvents BindNetEvents
  短暂存在的对象，如Frame（UI）, 使用	register handlers/ register ui event, 如RegisterUIEvent(Handler)
  
  对于短暂存在对象内部的子对象，如果子对象也需要绑定/注册事件回调，可以用bind event handlers
  ```
  
  

* init vs. initialize vs. uninit vs. deinit

  ``` tex
  配套使用
  init()  deinit() 清理函数
  
  initialize() uninitialize() 卸载
  
  initView()  clearView()  refreshView()
  
  updateData()
  ```

  

* variable(s) vs. param(s)

  ``` tex
  ref: https://stackoverflow.com/questions/63941547/what-is-the-difference-between-a-variable-and-a-parameter
  A variable is just something that refers/points to some data you have.
  
  x = 5
  Here x is a variable. Variables can point to more kinds of data than just numbers, though. They can point to strings, functions, etc.
  
  A parameter is something that is passed into a function
  
  def my_function(y):
      print(y)
  Here y is a parameter. It doesn't contain a value yet. But if I want to call the function, I need to provide an argument to the function.
  
  An argument is the actual value you provide to the function that replaces the parameter.
  
  my_function(5)
  Here, 5 is the argument. Of course, since x points to the value "5", I can do this too:
  
  my_function(x)
  which also prints 5
  ```






* indexes vs. indices

  ``` tex
  两者等同
  
  全球范围内 indices较多
  
  indices常用于数学、科学、统计方面
  indexes用于书目和清单
  ```

* pending vs. waiting / awaiting

  ``` tex
  Awaiting Review has the implication that the review has not started yet. 		Awaiting Review意味着审查还没有开始。
  Pending Review simply implies that the review has not been completed. 			Pending Review仅仅意味着审查还没有完成。
  
  Something can be both Awaiting Review and Pending Review but once something is in the process of being reviewed it is no longer Awaiting Review but it is still Pending Review 
  有些东西既可以是等待审查，也可以是等待审查，但一旦某些东西处于被审查的过程中，它就不再是等待审查，但仍然是等待审查
  
  
  The words ‘wait’ and ‘await’ are quite identical in their meaning and seem synonymous, but one should not use them interchangeably. This is so because ‘await’ is more formal, as compared to ‘wait’. ‘Wait‘ means to pass the time until an anticipated event occurs, whereas ‘await‘ means to wait for something with a hope. 
  Now let’s understand the differences between wait and await with the help of examples: 
  The Principal was waiting for the Chief guest to arrive, but the Chief guest was awaiting the call. 
  The Director said, “Clients have to wait, as the new project is awaiting approval of the Central Government.” 
  In these two examples, you might have observed, that the word wait is used in the context of repose, pause or delay, whereas await is used when someone/something is waiting with anticipation. 
  
  “wait”和“await”这两个词在意思上是完全相同的，似乎是同义词，但人们不应该把它们互换使用。
  这是因为与wait相比，await更正式。Wait的意思是消磨时间直到预期的事件发生，而await的意思是带着希望等待某事。
  
  现在让我们通过例子来了解wait和await的区别:
  校长在等首席客人来，但首席客人在等电话。
  主任说:“客户必须等待，因为新项目正在等待中央政府的批准。”
  在这两个例子中，你可能已经注意到，wait这个词用于休息、暂停或延迟的上下文中，而await则用于某人或某事期待地等待。
  ```




* research vs. search agein

  ``` tex
  research 搜索
  search agein 重新检索
  ```

* limit vs. constraint / restriction

  ``` tex
  limit 极限
  
  restriction  n. / constraint v. 限制
  ```

* fasten vs. accelerate

  ``` tex
  fasten 固定
  
  accelerate 加速
  ```

  

 





---



### 基本架构

* MVC vs. MVP vs. MVVM

  ref: https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html

  ``` tex
  MVC
  
  单向通信
  View -> Controller -> Model -> View
  视图（View）：用户界面。
  控制器（Controller）：业务逻辑
  模型（Model）：数据保存
  
  View 传送指令到 Controller
  Controller 完成业务逻辑后，要求 Model 改变状态
  Model 将新的数据发送到 View，用户得到反馈
  
  
  互动模式 （接受用户指令）
  一种是通过 View 接受指令，传递给 Controller。
  User -> View -> Controller -> Model -> View
  
  另一种是直接通过controller接受指令。
  User -> Controller -> Model -> View
  
  项目灵活配置
  User -> View <-> Controller —> Model <-> View
  User -> Controller ...
  1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。
  2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。
  3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。
  
  
  ------------------------------------------------------------------------------------
  
  
  MVP
  
  双向通信
  View <->  Presenter <-> Model
  1. 各部分之间的通信，都是双向的。
  2. View 与 Model 不发生联系，都通过 Presenter 传递。
  3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。
  
  
  
  -------------------------------------------------------------------------------------
  
  MVVM
  
  View <-双向绑定-> ViewModel <->  Model
  类似于MVP，唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。
  ```

  

---



### 几种模式

```tex
三个数据后面都缺了一个词，分别是：“编程”、“架构”和“开发”(或“软件工程”)。 同时，不是“面向”组件而是“基于”组件。

面向对象编程(Object-Oreinted Programming) 是一种编程范式。指在设计程序时大量运用类实例对象的方式。OOP一旦在项目中被运用，就成了时刻要考虑的东西。
面向服务架构(Service-Oreinted Architecture) 是将软件设计成一组可互操作的服务的一套原则或方法论。通常在考虑系统架构时才会触及SOA。
基于组件开发(Component-Based Development) 是一种软件工程实践，设计时通常要求组件之间高内聚，松耦合。其接口可能是OO的，调用方式可能是以Service的方式。基于组件开发关注系统层次、子 系统边界和子系统间通讯的的设计，处于代码层面但不像OOP的一样是时刻需要运用的东西。

三者身处软件开发的不同层面，因此说他们用于“哪些领域”并不恰当。不论是哪个领域的软件开发，都可能要同时面对OOP、SOA和CBD。摘自：http://blog.sina.com.cn/s/blog_6d2890600101cwih.html

2、面向对象编程 （OOP） 面向组件编程（COP） 
   面向方面编程（AOP）  面向服务编程（SOP）

1、什么是面向对象编程（Object-Oriented Programming）？ 
面向对象编程（Object-Oriented Programming）简称OOP技术，是开发计算机应用程序的一种新方法、新思想。过去的面向过程编程常常会导致所有的代码都包含在几个模块中，使程序难以阅读和维护。在做一些修改时常常牵一动百，使以后的开发和维护难以为继。而使用OOP技术，常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的，这样就增大了代码重用的几率，更加有利于软件的开发、维护和升级。
在面向对象中，算法与数据结构被看做是一个整体，称作对象，现实世界中任何类的对象都具有一定的属性和操作，也总能用数据结构与算法两者合一地来描述，所以可以用下面的等式来定义对象和程序：
对象=（算法+数据结构），程序=（对象+对象+……）。 
从上面的等式可以看出，程序就是许多对象在计算机中相继表现自己，而对象则是一个个程序实体。 

2、什么是面向组件编程（Component-Oriented Programming）？ 
组件不是一个新的概念，Java中的javaBean规范和EJB规范都是典型的组件。组件的特点在于他定义了一种通用的处理方式。例如，JavaBean 拥有内视的特性，这样就可以通过工具来实现JavaBean的可视化。而EJB规范定义了企业服务中的一些特性，使得EJB容器能够为符合EJB规范的代码增添企业计算所需要的能力，例如事务、持久化、池等。
所以，组件比起对象来的进步就在于通用的规范的引入。通用规范往往能够为组件添加新的能力（就像上面所讨论的），但也给组件添加了限制，例如你需要实现EJB的一些接口 
COP比OOP更进一步。通常OOP将数据对象组织到实体中。这种方法具有很多优点。但是，OOP有一个大的限制：对象之间的相互依赖关系。去掉这个限制的一个好的想法就是组件。组件和一般对象之间的关键区别是组件是可以替代的。

3、什么是面向方面编程（Aspect-Oriented Programming）？ 
将通用需求功能从不相关类之中分离出来；同时，能够使得很多类共享一个行为，一旦行为发生变化，不必修改很多类，只要修改这个行为就可以。 
AOP就是这种实现分散关注的编程方法，它将“关注”封装在“方面”中。 

4、什么是面向服务编程（Service-Oriented Programming）？ 
SOP是一种体系结构，目标是在软件代理交互中获得松散耦合。一个服务是一个服务提供者为一个服务消费者获得其想要的最终结果的一个工作单元。服务者与消费者都以软件代理代表他们自己的角色。
    这听起来有些太抽象，但是SOP确实无处不在。让我们在你的住房中找到一个SOP的例子。例如播放一个CD,你可以将要播放的CD放入CD机中，CD机将为你播放这张CD，CD机提供了一个CD播放服务。这里的好处就是你可以用不同的CD机去播放同一张CD。他们能提供同样的CD播放服务，但是服务质量是不同的。
    SOP的思想明显不同于面向对象的编程，面向对象编程强烈的建议你应该将数据与其操作绑定。因此在面向对象编程风格中，每张CD 有它自己的CD播放机，他们之间不能被拆开。这听起来很奇怪，但是这就是我们建立许多已存软件系统的方式。
而SOP就不一样了，为了减少异构性、互操作性和不断改变的要求的问题，这样的体系结构应该提供平台来构建具有下列特征的应用程序服务： 
松散耦合、位置透明、协议独立 
    基于这样的面向服务的体系结构，服务使用者甚至不必关心与之通信的特定服务，因为底层基础设施或服务“总线”将代表使用者做出适当的选择。基础设施对请求者隐藏了尽可能多的技术。特别地，来自不同实现技术（如 J2EE 或 .NET）的技术规范不应该影响 SOP用户。如果已经存在一个服务实现，我们就还应该重新考虑用一个“更好”的服务实现来代替，新的服务实现必须具有更好的服务质量。
 
OOA:
Object Oriented Analysis 面向对象分析方法

OOD:
Object Oriented Design 面向对象设计

OOP:
Object Oriented Programming 面向对象的程序设计
```





---



### 游戏设计模式





---



### 代码整洁之道

* **整洁代码的书写格式，可以遵从如下几个原则：**

  ``` tex
  第一原则：像报纸一样一目了然。优秀的源文件也要像报纸文章一样，名称应当简单并且一目了然，名称本身应该足够告诉我们是否在正确的模块中。源文件最顶部应该给出高层次概念和算法。细节应该往下渐次展开，直至找到源文件中最底层的函数和细节。
  
  第二原则：恰如其分的注释。带有少量注释的整洁而有力的代码，比带有大量注释的零碎而复杂的代码更加优秀。
  
  第三原则：合适的单文件行数。尽可能用几百行以内的单文件来构造出出色的系统，因为短文件通常比长文件更易于理解。
  
  第四原则：合理地利用空白行。在每个命名空间、类、函数之间，都需用空白行隔开。
  
  第五原则：让紧密相关的代码相互靠近。靠近的代码行暗示着他们之间的紧密联系。所以，紧密相关的代码应该相互靠近。
  
  第六原则：基于关联的代码分布。
  
  - 变量的声明应尽可能靠近其使用位置。
  - 循环中的控制变量应该在循环语句中声明。
  - 短函数中的本地变量应当在函数的顶部声明。
  - 对于某些长函数，变量也可以在某代码块的顶部，或在循环之前声明。
  - 实体变量应当在类的顶部声明。
  - 若某个函数调用了另一个，就应该把它们放到一起，而且调用者应该尽量放到被调用者上面。
  - 概念相关的代码应该放到一起。相关性越强，则彼此之间的距离就该越短。
  
  第七原则：团队遵从同一套代码规范。一个好的团队应当约定与遵从一套代码规范，并且每个成员都应当采用此风格。
  ```

  
