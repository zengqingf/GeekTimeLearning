* 搜索算法

  * 广度优先搜索

    * 基本实现和特性

      BFS 是从一个顶点V~0~ 开始，沿着图的宽度遍历图中的结点，如果所有结点均被访问或找到要查找的元素，即算法中止

    * 复杂度

      * 时间复杂度

        O(E)

      * 空间复杂度

        O(V)

    * 步骤

      广度优先搜索队列实现

      1. 顶点V~0~ 放到队列末尾
      2. 每次从队列的头部取出一个元素，查看这个元素的相邻结点，把他们放到队列末尾，并把这个元素记为它下一级元素的前驱
      3. 找到所有要找的元素时，结束程序
      4. 如果遍历整个图还没有找到，结束程序

    * 应用

      1. Dijkstra单源最短路径算法
      2. Prim最小生成树算法

  * 深度优先搜索

    * 基本实现和特性

      DFS时从一个顶点V~0~ 开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个结点，然后从另一条路开始走到底

    * 复杂度

      * 时间复杂度

        O(E)

      * 空间复杂度

        O(V)

    * 步骤

      深度优先遍历图的方法是，从图中某顶点V~0~ 出发

      1. 访问顶点V~0~
      2. 依次从V~0~的未被访问的领接点出发，对图进行深度优先遍历，直至图中和V~0~有路径相通的顶点都被访问
      3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，知道图中所有顶点均被访问过为止

    * 应用

      树和图的搜索

  * A*算法

    A-Star算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是解决许多搜索问题的有效算法

    算法中的距离估算与实际值越接近，最终搜索速度越快





---



* 递归

  * 概念

    方法或函数调用自身的方式 称为 递归，其中调用称为递，返回称为归

  * 思维要点

    1. 一个问题的解可以分解为几个子问题的解
    2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
    3. 存在递归终止条件

  * 代码模版

    1. 找到将大问题分解为小问题的规律
    2. 写出递归公式
    3. 找到终止条件

    注意避免堆栈溢出，重复计算

  * 应用

    1. 汉诺塔问题

    2. 斐波那契数列

    3. 阶乘问题

       ``` tex
       4！ = 4 x 3 x 2 x 1
                             f(x)
                               if x > 1 then
                                 x * f(x - 1)
                               end
                             end
       f(4) = 4 x f(3)												f(4) = 4 x 3 x 2 x 1
       	f(3) = 3 x f(2)												f(3) = 3 x 2 x 1
       		f(2) = 2 x f(1)												f(2) = 2 x 1
       												f(1) = 1			

    4. 数组的全排列

  * 常考面试题

    1. DFS算法
    2. 二叉树的前中后序遍历
    3. 归并排序



---



* 分治算法

  * 概念

    核心思想是分而治之，将原问题划分为n个规模较小并且结构与原问题相似的子问题，递归的解决这些子问题，再合并其结果，得到原问题的解

  * 和递归的区别

    分治算法是一种处理问题的思想，递归是一种编程技巧，分治算法一般都较合适用递归来实现

  * 基本实现和特性

    分治算法的递归实现，分一层递归都会涉及以下三个操作

    1. 分解：将原问题分解为一系列子问题
    1. 解决：递归求解各个子问题，若子问题足够小，则直接求解
    1. 合并：将子问题结果合并为原问题

  * 应用
  
    1. 在算法设计过程中降低求解问题的时间
    2. 解决海量数据处理问题，比如MapReduce([Google](https://zh.wikipedia.org/wiki/Google)提出的一个[软件架构](https://zh.wikipedia.org/wiki/软件架构)，用于大规模数据集（大于1[TB](https://zh.wikipedia.org/wiki/Terabyte)）的[并行运算](https://zh.wikipedia.org/wiki/並行運算))
  
  * 常考算法题
  
    1. 二分查找
    2. 大整数乘法
    3. 合并排序
    4. 快速排序
    5. 棋盘覆盖
    6. 求出一组数据的有序对个数或者逆序对个数
    7. 二维平面上有N个点，如何快速计算出两个距离最近的点对
    8. 有两个n*n的矩阵A、B，如何快速求解两个矩阵的乘积 C = A * B





---



* 回溯算法

  * 概念

    实际上类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径

    回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标，但当探索到某一步时，发现原先选择条件并不优活达不到目标，就退回一步重新选择，这种走不通就退回再走的技术即 回溯法，而满足回溯条件的某个状态的点称为 “回溯点”

    适合处理 复杂 规模较大的问题

  * 基本实现和特性

    一般步骤：

    1. 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解
    2. 确定易于搜索的解空间结构，使得能用回溯法方便地搜索整个解空间
    3. 以深度优先方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索

  * 注意点

    1. 回溯算法非常适合用递归代码实现
    2. 回溯算法在实现过程中，剪枝操作可以提高回溯效率，利用剪枝，并不需要穷举搜索所有情况，从而提高搜索效率

    常见剪枝函数：

    1. 约束函数：在扩展结点处减去不满足约束的子树
    2. 限界函数：减去得不到最优解的子树

  * 适用场景

    由于回溯法的时间复杂度高，有指数级别，因此适用于较小规模的数据

  * 常考面试题

    1. 深度优先搜索算法
    2. 数独
    3. 八皇后问题
    4. 0-1背包
    5. 图的着色
    6. 旅行商问题
    7. 全排列问题
    8. 正则表达式
    9. 编译原理的语法分析



---



* 贪心算法

  * 概念

    是指对问题求解时，总是做出在当前看来不是最好的选择，由于不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解

  * 基本实现和特性

    基本思路：从问题的某一初始解出发一步步地进行，根据某个优化测度，每一步都要确保能获得局部最优解，每一步只考虑一个数据，选取应该满足局部优化的条件，若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加时算法停止

    步骤：

    1. 建立数学模型来描述问题
    2. 把求解的问题分成若干子问题
    3. 对每一子问题求解，得到子问题的局部最优解
    4. 把子问题的解局部最优解合成原来解问题的一个解

  * 应用

    1. 霍夫曼编码
    2. Prim 和 Kruskal 最小生成树
    3. Dijkstra 单源最短路径
    4. 任务调度

  * 常考面试题

    1. 分苹果：有m个苹果和n个孩子(m < n) ，m个苹果大小不同，n个孩子对苹果大小需求不同，如何分配让最多数量的孩子得到苹果
    2. 钱币找零：有1元、2元、5元、10元，且张数分别是 a~1~ a~2~ a~3~ a~4~ ，用这些钱来支付M元，最少需要几张

  * 和动态规划的区别

    贪心不保证求得的最后解是最佳的，一般复杂度低

    动态规划本质是穷举法，可以保证结果是最佳的，但复杂度高

    * 相同点

      1. 都是一种推导算法
      2. 都是分解成子问题来求解，都需要具有最优子结构

    * 不同点1

      贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留

      动态规划：全局最优解一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有局部最优解

    * 不同点2

      贪心：如果把所有子问题看出一棵树的话，贪心从根出发，每次向下遍历最优子树即可（通常这个“最优”都是基于当前情况下明显的“最优”），即不需要知道一个结点的所有子树的情况，构不成一棵完整的树

      动态规划：自底向上，从叶子向根，构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值，得到答案

      

      

---



* 动态规划

  * 概念

    每次决策依赖于当前状态，又回随即引起状态的转移，一个**决策序列**就是在变化的状态中产生出来的，所以，这种**多阶段最优化决策解决问题的过程**即为 动态规划

  * 适用场景

    1. 最优子结构

       指问题的最优解包含子问题的最优解，即通过子问题的最优解可以推导出问题的最优解

    2. 无后效性

       即某阶段状态一旦确定，就不受这个状态之后决策的影响，即某状态以后的过程不会影响以前的状态，只和当前状态有关

    3. 重复子问题

       不同的决策序列，到达某个相同的阶段时，可能产生重复的状态（该性质并不是动态规划适用的必要条件，但如果没有这条性质，动态规划算法和其他算法相比就不具备优势）

  * 回溯、贪心、分治、动态规划的比较

    1. 回溯法：指数级别的算法，复杂度高，只能用于处理小规模数据的问题
    2. 能用动态规划的问题具有最优子结构、无后效性和重复子问题三个特性
    3. 在重复子问题上，分治算法要求分割成子问题不能有重复子问题，而动态规划需要有重复子问题
    4. 贪心算法可以看出动态规划算法的一种特殊情况

  * 状态转移方程

    状态转移方程是解决动态规划问题的关键

    分析某个问题如何通过子问题来递归求解，即最优子结构，根据最优子结构，写出状态转移方程

    实现状态转移方程方法：

    1. 递归 + “备忘录”
    2. 迭代递推

  * 解题思路

    1. 分析最优解的性质，并刻画其结构特征
    2. 递归定义最优解
    3. 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
    4. 根据计算最优值时得到的信息，构造问题最优解

  * 动态规划应用

    动态规划比较适合求解最优问题，如最大值、最小值，动态规划可以限制降低时间复杂度

  * 常考面试题

    1. 背包问题
    2. 计算两个字符串的相似度
    3. 最长公共子串长度
    4. 求最长递增子序列
    5. 最小编辑距离
    6. 爬楼梯
    7. 连续子数组的最大和
    8. 最长回文子串



---



* 二分查找

  * 概念

    二分查找每次选取区间的中间元素进行比较，将查找区间缩小为一半，直到找到要查找的元素或者区间长度为0，结束查找，类似分治

  * 前提条件

    数组有序

  * 查找效率

    O(logn)

  * 代码模版

    递归写法 和 非递归写法

  * 易错点

    1. 循环退出的条件
    2. 每次查找区间一半mid的取值
    3. 查找区间left、right的每次更新情况

  * 应用

    适用于处理静态数据，没有频繁地插入、删除数据操作

  * 局限

    1. 必须依赖顺序表（数组）
    2. 查找必须是有序数据
    3. 数据量太小不适合二分查找

  * 常考面试题

    1. 查找第一个值等于给定值的元素
    2. 查找最后一个值等于给定值的元素
    3. 查找第一个大于等于给定值的元素
    4. 查找最后一个小于等于给定值的元素
    5. 旋转数组的二分查找



---



* 哈希算法

  * 概念

    将任意长度的二进制串映射为固定长度的二进制值串，映射规则即为哈希算法

    通过原始数据映射后得到的二进制值串即为哈希值

  * 常见应用

    1. 安全加密
    2. 唯一标识
    3. 数据校验
    4. 散列函数
    5. 负载均衡
    6. 数据分片
    7. 分布式存储