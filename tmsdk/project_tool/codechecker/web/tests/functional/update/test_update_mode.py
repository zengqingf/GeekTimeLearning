#
# -------------------------------------------------------------------------
#
#  Part of the CodeChecker project, under the Apache License v2.0 with
#  LLVM Exceptions. See LICENSE for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# -------------------------------------------------------------------------
"""
Test update mode where multiple analysis results stored in the same run.
For the test reports were not generated by CodeChecker so metadata
information (analysis command ...) are not available/stored.
"""


import os
import sys
import unittest

from libtest import env
from libtest import codechecker
from libtest.debug_printer import print_run_results
from libtest.thrift_client_to_db import get_all_run_results

from codechecker_api.codeCheckerDBAccess_v6.ttypes import DetectionStatus


class TestUpdate(unittest.TestCase):

    def setUp(self):
        self._test_workspace = os.environ.get('TEST_WORKSPACE')

        test_class = self.__class__.__name__
        print('Running ' + test_class + ' tests in ' + self._test_workspace)

        self._clang_to_test = env.clang_to_test()

        self._testproject_data = env.setup_test_proj_cfg(self._test_workspace)
        self.assertIsNotNone(self._testproject_data)

        self._cc_client = env.setup_viewer_client(self._test_workspace)
        self.assertIsNotNone(self._cc_client)

        # Get the run names which belong to this test
        run_names = env.get_run_names(self._test_workspace)

        runs = self._cc_client.getRunData(None, None, 0, None)

        test_runs = [run for run in runs if run.name in run_names]

        self.assertEqual(len(test_runs), 1,
                         'There should be only one run for this test.')
        self._runid = test_runs[0].runId
        self._run_name = test_runs[0].name

    def test_disable_checker(self):
        """
        The test depends on a run which was configured for update mode.
        Compared to the original test analysis in this run
        the deadcode.Deadstores checker was disabled.
        In this case the reports are marked as resolved.
        """

        run_results = get_all_run_results(self._cc_client, self._runid)

        print_run_results(run_results)

        # Get check command for the first storage.
        original_check_command = \
            self._cc_client.getCheckCommand(None, self._runid)

        self.assertEqual(original_check_command, "")

        initial_codechecker_cfg = env.import_test_cfg(
            self._test_workspace)['codechecker_cfg']

        initial_test_project_name = self._run_name

        disabled_reports = os.path.join(
            self._testproject_data['test_project_reports'], 'disabled')

        initial_codechecker_cfg['reportdir'] = disabled_reports
        ret = codechecker.store(initial_codechecker_cfg,
                                initial_test_project_name)
        if ret:
            sys.exit(1)

        # Get the results to compare.
        updated_results = get_all_run_results(self._cc_client, self._runid)

        for report in updated_results:
            self.assertEqual(report.detectionStatus, DetectionStatus.RESOLVED)
